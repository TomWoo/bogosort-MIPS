Bogosort (specifically bozosort) implementation in MIPS... enjoy! Make sure you find my secret comment lovingly nested within the 400 or so lines of code.

MARS is required to run bogosort.s because I rely on macro for function definitions and .eqv tags for constant definitions. I still adhere to calling conventions, though macros conveniently eliminate the need to offset the stack pointer before and after function calls. The current implementation only supports non-negative 32-bit signed integers as user input to populate nodes to be sorted (negative integers signal the program to stop accepting additional input), but it would be very technically feasible to refactor it to support sorting of floating-point real numbers. Two caveats are as follows: (1) there is no error-handling of user input, but I could conceivable make use of the exception registers in the future; (2) the user must enter at least one piece of data (one non-negative integer) before signaling the end of the list, or else the program segfaults.
Bozosort is a highly inefficient sorting algorithm that generates random permutations of a list by swapping two elements at a time until the list is sorted. Because it has an average runtime performance of O((N+1)!), where N is the number of initial elements in the list to be sorted (the number of user inputs), you are advised not to run bogosort.s with a very high N -- otherwise, you might need to wait a very long time for the correct result. The random number (positive integer) generator uses a Galois linear feedback shift register (LFSR) with taps based on a known good (maximal) feedback polynomial.
